O(1) - постоянная сложность: Время выполнения алгоритма остается постоянным независимо от размера входных данных. Примером может быть доступ к элементу по индексу в массиве или выполнение простых арифметических операций.

O(log(n)) - логарифмическая сложность: Время выполнения алгоритма увеличивается логарифмически по размеру входных данных. Примером может быть бинарный поиск.

O(n) - линейная сложность: Время выполнения алгоритма пропорционально размеру входных данных. Примером может быть линейный поиск или обход массива.

O(n log(n)) - линейно-логарифмическая сложность: Время выполнения алгоритма увеличивается пропорционально размеру входных данных, умноженному на логарифм размера входных данных. Примером может быть сортировка слиянием или быстрая сортировка.

O(n^2) - квадратичная сложность: Время выполнения алгоритма увеличивается квадратично по размеру входных данных. Примером может быть алгоритм сортировки вставками или алгоритм сортировки выбором.

O(2^n) - экспоненциальная сложность: Время выполнения алгоритма увеличивается экспоненциально по размеру входных данных. Примером может быть задача о коммивояжере, решаемая методом полного перебора.

в порядка сложности:

O(1) - постоянная сложность (наименьшая)
O(log(n)) - логарифмическая сложность
O(n) - линейная сложность
O(n log(n)) - линейно-логарифмическая сложность
O(n^2) - квадратичная сложность
O(2^n) - экспоненциальная сложность (наибольшая)

как определить сложность по коду-

"""

def example_algorithm(arr):
    n = len(arr)
    total = 0
    
    # Линейная сложность - O(n)

    for item in arr:
        total += item
    
    # Временная сложность этой части зависит от структуры данных или реализации sum()
    # В общем случае, если предположить, что sum() выполняется за O(n), то эта часть также имеет сложность O(n)

    total_sum = sum(arr)
    
    # Квадратичная сложность - O(n^2)
    for i in range(n):
        for j in range(n):
            print(i, j)
    
    # Логарифмическая сложность - O(log(n))
    while n > 1:
        n = n // 2
    
    return total, total_sum


Для определения общей сложности функции, мы должны учесть сложность каждой из частей и выбрать наиболее значимую сложность.

Сложность цикла for item in arr: O(n)
Сложность вызова sum(arr): O(n) (предположим, что стандартная функция sum работает за линейное время)
Сложность вложенного цикла for i in range(n): for j in range(n):: O(n^2)
Сложность цикла while n > 1: O(log(n))
Таким образом, наиболее значимая сложность из перечисленных - квадратичная сложность O(n^2), поскольку она растет быстрее, чем линейная или логарифмическая сложность. Таким образом, общая сложность функции example_algorithm можно оценить как O(n^2).

Вот пример кода с экспоненциальной временной сложностью:


def exponential(n):
    if n == 0:
        return 1
    else:
        return 2 * exponential(n - 1)